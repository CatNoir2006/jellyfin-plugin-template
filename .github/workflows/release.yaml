# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json

name: 'ðŸš€ 3rd-Party Release'

on:
  release:
    types: [published]
  workflow_dispatch:

# IMPORTANT:
# 1. Replace 'YOUR_USERNAME/YOUR_MANIFEST_REPO' with the name of your manifest repository.
# 2. Go to your plugin repository's settings -> Secrets and variables -> Actions.
# 3. Create a new "Repository secret" named "MANIFEST_PAT".
# 4. Paste your Personal Access Token (PAT) into the secret's value. The PAT needs write access to your manifest repository.
env:
  MANIFEST_REPO: 'YOUR_USERNAME/YOUR_MANIFEST_REPO' # <-- âš ï¸ CHANGE THIS
  PLUGIN_GUID: ''

permissions:
  contents: write

jobs:
  build-and-upload:
    name: 'Build & Upload to Release'
    runs-on: ubuntu-latest
    outputs:
      artifact_path: ${{ steps.jprm.outputs.artifact }}
      artifact_name: ${{ steps.get_filename.outputs.ASSET_FILENAME }}

    steps:
      - name: 'Checkout Plugin Repo'
        uses: actions/checkout@v4

      - name: 'Setup .NET'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: 'Update build.yaml for JPRM'
        if: github.event_name == 'release'
        id: update_build_yaml
        shell: python
        run: |
          import yaml
          import os
          
          build_file = 'build.yaml'
          release_body = os.environ.get('RELEASE_BODY', '')
          # Clean up release_body from markdown to plain text for changelog
          # Simple markdown removal for common elements
          release_body = release_body.replace('**Full Changelog**:', '').strip()
          
          with open(build_file, 'r') as f:
              build_config = yaml.safe_load(f)

          build_config['changelog'] = release_body

          with open(build_file, 'w') as f:
              yaml.dump(build_config, f, sort_keys=False)
        env:
          RELEASE_BODY: ${{ github.event.release.body }}

      - name: 'Build Jellyfin Plugin using JPRM'
        id: jprm
        uses: oddstr13/jellyfin-plugin-repository-manager@v1.1.1
        with:
          dotnet-target: "net9.0"


      - name: 'Get Asset Filename'
        id: get_filename
        run: echo "ASSET_FILENAME=$(basename ${{ steps.jprm.outputs.artifact }})" >> $GITHUB_OUTPUT

      - name: 'Calculate Checksum'
        id: checksum
        run: |
          CHECKSUM_VALUE=$(md5sum "${{ steps.jprm.outputs.artifact }}" | cut -d' ' -f1)
          echo "$CHECKSUM_VALUE" > checksum.txt # Write to file
          echo "checksum=$CHECKSUM_VALUE" >> $GITHUB_OUTPUT # Still output to GITHUB_OUTPUT for good measure

      - name: 'Upload Artifact to Release'
        if: github.event_name == 'release'
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: ${{ steps.jprm.outputs.artifact }}
          asset_name: ${{ steps.get_filename.outputs.ASSET_FILENAME }}
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}


      - name: 'Upload checksum for next job'
        uses: actions/upload-artifact@v4
        with:
          name: checksum-artifact
          path: checksum.txt # Only upload the checksum file
          retention-days: 1

  update-manifest:
    name: 'Update Manifest File'
    needs: build-and-upload
    runs-on: ubuntu-latest

    steps:
      - name: 'Checkout Plugin Repo (for build.yaml)'
        uses: actions/checkout@v4
        with:
          path: plugin-repo

      - name: 'Checkout Manifest Repo'
        uses: actions/checkout@v4
        with:
          repository: ${{ env.MANIFEST_REPO }}
          token: ${{ secrets.MANIFEST_PAT }}
          path: manifest-repo

      - name: 'Download checksum artifact'
        uses: actions/download-artifact@v4
        with:
          name: checksum-artifact

      - name: 'Setup Python'
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: 'Install Python Dependencies'
        run: pip install pyyaml

      - name: 'Update Manifest JSON'
        id: update_json
        shell: python # <-- Added this
        run: |
          import json
          import os
          import yaml
          from datetime import datetime

          manifest_path = 'manifest-repo'
          plugin_path = 'plugin-repo'
          manifest_file = os.path.join(manifest_path, 'manifest.json')
          build_file = os.path.join(plugin_path, 'build.yaml')

          plugin_guid = os.environ['PLUGIN_GUID']

          # --- Read build.yaml for plugin metadata ---
          with open(build_file, 'r') as f:
              build_config = yaml.safe_load(f)

          # --- Info from release event and previous job ---
          tag_name = os.environ['GITHUB_REF_NAME']
          version_str = tag_name.lstrip('v')
          release_body = os.environ.get('RELEASE_BODY', 'See release notes.')
          repo_slug = os.environ['GITHUB_REPOSITORY']
          artifact_name = os.environ['ARTIFACT_NAME']

          # Read checksum from file
          with open('checksum.txt') as f:
              checksum = f.read().strip()

          # Construct the source URL
          source_url = f"https://github.com/{repo_slug}/releases/download/{tag_name}/{artifact_name}"

          # Create the new version entry
          new_version_entry = {
              "version": version_str,
              "changelog": release_body,
              "timestamp": datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%SZ'),
              "sourceUrl": source_url,
              "checksum": checksum,
              "targetAbi": build_config.get('targetAbi', 'unknown')
          }

          # Read the existing manifest or initialize an empty list if it doesn't exist or is invalid
          manifest_data = []
          try:
              with open(manifest_file, 'r') as f:
                  manifest_data = json.load(f)
          except (FileNotFoundError, json.JSONDecodeError):
              print(f"'{manifest_file}' not found, empty, or invalid. Will create a new one.")
              manifest_data = []

          # Find plugin by GUID and update/create it
          plugin_found = False
          for plugin in manifest_data:
              if plugin.get('guid') == plugin_guid:
                  # Update top-level metadata from build.yaml if plugin exists
                  plugin['category'] = build_config.get('category', 'General')
                  plugin['name'] = build_config.get('name', 'Unknown Plugin')
                  plugin['description'] = build_config.get('description', '')
                  plugin['owner'] = build_config.get('owner', 'Unknown Owner')
                  plugin['overview'] = build_config.get('overview', '')

                  # Prepend the new version to the existing plugin's versions list
                  plugin['versions'].insert(0, new_version_entry)
                  plugin_found = True
                  break

          if not plugin_found:
              print(f"Plugin with GUID {plugin_guid} not found. Creating new entry.")
              new_plugin_entry_obj = {
                  "category": build_config.get('category', 'General'),
                  "guid": plugin_guid,
                  "name": build_config.get('name', 'Unknown Plugin'),
                  "description": build_config.get('description', ''),
                  "owner": build_config.get('owner', 'Unknown Owner'),
                  "overview": build_config.get('overview', ''),
                  "versions": [new_version_entry]
              }
              manifest_data.append(new_plugin_entry_obj)

          # Write the updated data back to the manifest file
          with open(manifest_file, 'w') as f:
              json.dump(manifest_data, f, indent=4)

        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BODY: ${{ github.event.release.body }}
          ARTIFACT_NAME: ${{ needs.build-and-upload.outputs.artifact_name }}

      - name: 'Commit and Push Manifest Changes'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'ci: Update manifest for ${{ env.PLUGIN_NAME }} v${{ github.ref_name }}'
          commit_user_name: 'github-actions[bot]'
          commit_user_email: 'github-actions[bot]@users.noreply.github.com'
          repository: 'manifest-repo'
        env:
          PLUGIN_NAME: 'Test Plugin'


